
/*
　車の移動は、CarClassの中。
　ここはデバッグ的な操作か、攻撃手段(仮実装)の操作。
*/

int range=3;

void keyPressed()
{
 if(key=='z')
 {
   /*
   //explosion-test
   data[(int)car.X.y][(int)car.X.x]*=0.9;
   */
   
   //myself-explosion
   for(int j=(int)(car.X.x)-range; j<(int)(car.X.x)+range; j++)
   {
     for(int i=(int)(car.X.y)-range; i<(int)(car.X.y)+range; i++)
     {
       data[i][j]+=1;
     }
   }
   
   /*
   //map-attack
   for(int i=0; i<nrows; i++)
   {
     for(int j=0; j<ncols; j++)
     {
       data[i][j]*=0.5;
     }
   }
   */
 }
}




/*
　現在は、汎用的な3Dワールドとして使えないかと模索している。
　HanyouTestとは別口だ。

　なぜHanyouTestと別なのか、
　そもそもマイクラ的3Dの場合、ピクセル単位の処理やバッファの存在を意識したことがない、そこまで操作したことがない。
　ということは、HanyouTestみたいに機構組む必要が無いな。GUIが必要になったら、また別だけど、そのときはHanyoutestをゴソッとコピーしてくればいいか

　どちらかといえば、やるべきは、蛍光灯組み込んだみたいに、どんどんモデリング。
　マインクラフトみたいな世界に、P3Dの小物(設置汎用性がある証拠)を展示できるくらいにすべきか
*/
/*
　だからといって、ライブラリ入れてモデルがどんどん増えても、参考資料としては弱い。身にならない。蛍光灯くらいでいいかもしれない。
　CarWorldの「傾斜のある土地構築、その当たり判定」
　　　　　　  「車の挙動、向き移動や、特に車体の横転なども」
　　　　　　  「三次元空間へのマウスクリック(座標的な)」
　　　　　　  「その空間へ、別プログラムの別モデリングを組み込んだ」
　　   (todo)  「その空間内での射撃、及び土地への射撃接地」
　等の、ライブラリ頼らずに実装されているところを理解すべき。
　ただし、今、車の上に乗っている蛍光灯モデルはremixlab.proscene.*をimportしている。
*/


//////
/*
　とりあえず現在位置car.Xの高度をガクンと変えようとしている
　それが上手くいったら、グレネードでクレーター変形とか、ドリルでホール変形とか

　TAB_系は、参考のFujiCarにあるワールド生成やカメラ処理や車処理(=プログラムの基盤部分)を、
   ライブラリ的に、ほぼそのまま使っている塊の部分。
　そこから自由度に関わるもの(ワールド変形や、車体変形)を抽出したのが、TAB_のつかない塊の部分。

　TerrainSteeringとの比較：
　TerrainSteeringは「box描画に実体が伴う」タイプだった。つまり横長に変えれば、その部分が山にぶつかったりする。
　しかしこのFujiCarは、当たり判定は描画にあまり依存していない。車体を大きくすれば、余裕でめり込む。
　また、まあTerrainSteeringは完全にライブラリを使っているが、TerrainSteeringの方が相当読みやすい。

　・マウスによる移動
　・移動の「空中空間」への束縛軽微化
　・指定位置のワールド変形

　ができれば、TerrainSteeringの方がいいかもしれない。
　しかし、テクスチャを張ったものに当たり判定をつけるなら、
   TerrainSteeringはそこまでカバーしていないっぽいので、このままFujiCarを詰めて行く方がいいかもしれない。

*/
/*
　グレネード飛ばすために、車の向きを取得して、車から弾を飛ばし、地面との設置を取得するようにする。
　steerAngle？
*/

/*
　terrainの品質向上につながりそうなサンプルがあったので、読解して採用してみた。
　テクスチャとして凹凸床に貼る、といった感じ。特にtextureMode(NORMAL)が必要だった。
　元の方とterrainのサイズが違うので画質向上はなっていないが、元画像のサイズをterrainに合わせて拡大すれば、改善できる……？
*/
