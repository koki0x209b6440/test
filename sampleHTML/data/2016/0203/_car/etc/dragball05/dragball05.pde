/*
　ちなみに、影は自動ではなく「こんな形かなー」と思ったものをWorldBoxの床部らへんに黒色で描いているだけである
　Object3Dは、自身の描画と影の描画を同じ場所で行っている。つまり、そういう、適当なもの。
*/

/*
　WorldBoxは全体。
　当たり判定はWorldBox内で、gravityもcolidisionも全て管理(for(…objs.length…)的な)
　外枠の箱・世界はboxのnoFillによって描画してみた。

　ボールについて。基本的な挙動はObject3Dで標準装備されていると見ていい。
　ここでの当たり判定は、物体の頂点によって管理する。(めり込むけど、ちゃんと衝突はする)
   //  と思いきや、if(obj_type==TYPE_BALL)って、ボールの判定しかなかったわ
　当たり判定の拡張が行えるようにover()というメソッドが用意されてはいる。
　また、空間WorldBoxに重力概念くださいーと依頼して、加速度vxなどを自身に格納し
　、自分のところで位置演算しているようだ。

　そして、継承先のBasicBall3Dでは、半径rと、「ボールとしての当たり判定over(…);　」を用意。
　ここで見た目描画しましょうね、という見た目例も示した。

　更にそれを継承したColorfulBall3Dで、ボールの見た目を描いた。それ以外のことは気にしなくていいというスタンス。見た目を凝るためのクラスというかスペース。
　また描画というのは、影についても、である。影の位置は-env.z2というのが強烈に関係していそうだ。
　ちなみに、影は自動ではなく「こんな形かなー」と思ったものをWorldBoxの床部らへんに黒色で描いているだけである
*/
/*
　基本設計がとても読みやすく、Object3Dの継承でいろいろ転用しやすそう。
　Cartestと連携させたり、Cartestの世界の中に設置させたりできないかなー

　生成する3D空間に、マウスの処理(特に位置)を介在させることができる点がすばらしい。参考にしたい。

　ボール以外に歪な形(重心の位置概念入れた棒とか)に対応したり、カメラワークをよりマイクラ的にしたりで、
　Cartestとはまた違った有意義な箱庭になりそう
*/
/*
　箱庭ではなく、蛍光灯と同じ扱いにした。
　Cartestの世界に、このdragballを埋め込める。
　蛍光灯と違って、こっちは、移植の改変のポイントを書いておこうと思う。(二つ目だし)
　
　【移植できるように可用性を持たせる　ポイント】
　可用性をもたせたいオブジェクト・クラスの位置情報に注目する。
　今回だと箱庭WorldBoxと、その中のオブジェObject3D。

　今回でいえば「箱の始点はどこ？」という感じで、そのオブジェクトの基準点を探す。
　そして、x,y,zで管理できるようにする。例えばbox(0,0,0,   20);　→box(x,y,z,   20);
　そうすれば、任意のx,y,zへ置けるようになる。

　しかし、今回の場合、二つもおる。更に言えば、ボールであるObject3Dは複数だ。
　それら全てにx,y,zを追加していくのは手間すぎる。
　せっかくP3Dなので、以下のように書きたい。行列演算を活用したい。
　【シチュ：40,40,40にobjを設置したい】
　pushMatrix();
　translate(40,40,40)
　obj.work();              //  objは中身では、0,0,0を基準点に物を描いている
　popMatrix();
　しかしこの方法では、描画を移せるだけ。
　ボールと壁、ボールとボールはできても、マウスクリックの座標ズレは相当起こる。
　今回はマウスカーソルを隠すので、というかmouseXはtranslateX+mouseXにしたが、
違和感は無いが、うーん…蛍光灯のみたいに、scale小さくしたものにも当たり判定を付けるには、全部にちまちまxyzを付ける方がいいかなぁ
*/

WorldBox box;

void setup() {
  size(400, 400, P3D);
  box = new WorldBoxll(this,0, 0, 0, width, height, width, 10 );
  //noCursor();
  sphereDetail(20);
}

void draw() {
  background(240);
  
  //box.x1+=1;
  box.scaleValue=1.0f;
  box.update();
}











